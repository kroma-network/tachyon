4,13d3
< #include <iostream>
< #include <fstream>
< #include <sstream>
< #include <iomanip>
< #include <sys/stat.h>
< #include <sys/mman.h>
< #include <fcntl.h>
< #include <unistd.h>
< #include <vector>
< #include <chrono>
40c30
<   for (uint i = 0; i< inputSignalAssignedCounter; i++) {
---
>   for (int i = 0; i< inputSignalAssignedCounter; i++) {
72c62
<       pos = (pos+1)%n;
---
>       pos = (pos+1)%n; 
80c70
< void Circom_CalcWit::tryRunCircuit(){
---
> void Circom_CalcWit::tryRunCircuit(){ 
86c76
< void Circom_CalcWit::setInputSignal(u64 h, uint i,  FrElement const & val){
---
> void Circom_CalcWit::setInputSignal(u64 h, uint i,  FrElement & val){
96c86
< 
---
>   
137,298d126
< #define handle_error(msg) \
<            do { perror(msg); exit(EXIT_FAILURE); } while (0)
< 
< Circom_Circuit* loadCircuit(std::string const &datFileName) {
<   Circom_Circuit *circuit = new Circom_Circuit;
< 
<   int fd;
<   struct stat sb;
< 
<   fd = open(datFileName.c_str(), O_RDONLY);
<   if (fd == -1) {
<     std::cout << ".dat file not found: " << datFileName << "\n";
<     throw std::system_error(errno, std::generic_category(), "open");
<   }
< 
<   if (fstat(fd, &sb) == -1) {          /* To obtain file size */
<     throw std::system_error(errno, std::generic_category(), "fstat");
<   }
< 
<   u8* bdata = (u8*)mmap(NULL, sb.st_size, PROT_READ , MAP_PRIVATE, fd, 0);
<   close(fd);
< 
<   circuit->InputHashMap = new HashSignalInfo[get_size_of_input_hashmap()];
<   uint dsize = get_size_of_input_hashmap()*sizeof(HashSignalInfo);
<   memcpy((void *)(circuit->InputHashMap), (void *)bdata, dsize);
< 
<   circuit->witness2SignalList = new u64[get_size_of_witness()];
<   uint inisize = dsize;
<   dsize = get_size_of_witness()*sizeof(u64);
<   memcpy((void *)(circuit->witness2SignalList), (void *)(bdata+inisize), dsize);
< 
<   circuit->circuitConstants = new FrElement[get_size_of_constants()];
<   if (get_size_of_constants()>0) {
<     inisize += dsize;
<     dsize = get_size_of_constants()*sizeof(FrElement);
<     memcpy((void *)(circuit->circuitConstants), (void *)(bdata+inisize), dsize);
<   }
< 
<   std::map<u32,IODefPair> templateInsId2IOSignalInfo1;
<   if (get_size_of_io_map()>0) {
<     u32 index[get_size_of_io_map()];
<     inisize += dsize;
<     dsize = get_size_of_io_map()*sizeof(u32);
<     memcpy((void *)index, (void *)(bdata+inisize), dsize);
<     inisize += dsize;
<     assert(inisize % sizeof(u32) == 0);
<     assert(sb.st_size % sizeof(u32) == 0);
<     u32 dataiomap[(sb.st_size-inisize)/sizeof(u32)];
<     memcpy((void *)dataiomap, (void *)(bdata+inisize), sb.st_size-inisize);
<     u32* pu32 = dataiomap;
< 
<     for (uint i = 0; i < get_size_of_io_map(); i++) {
<       u32 n = *pu32;
<       IODefPair p;
<       p.len = n;
<       IODef defs[n];
<       pu32 += 1;
<       for (u32 j = 0; j <n; j++){
<         defs[j].offset=*pu32;
<         u32 len = *(pu32+1);
<         defs[j].len = len;
<         defs[j].lengths = new u32[len];
<         memcpy((void *)defs[j].lengths,(void *)(pu32+2),len*sizeof(u32));
<         pu32 += len + 2;
<       }
<       p.defs = (IODef*)calloc(10, sizeof(IODef));
<       for (u32 j = 0; j < p.len; j++){
<         p.defs[j] = defs[j];
<       }
< 	    templateInsId2IOSignalInfo1[index[i]] = p;
<     }
<   }
<   circuit->templateInsId2IOSignalInfo = std::move(templateInsId2IOSignalInfo1);
< 
<   munmap(bdata, sb.st_size);
< 
<   return circuit;
< }
< 
< void loadWitness(Circom_CalcWit *ctx, const absl::flat_hash_map<std::string, std::vector<FrElement>>& witness) {
<   size_t nItems = witness.size();
<   // printf("Items : %llu\n",nItems);
<   if (nItems == 0){
<     ctx->tryRunCircuit();
<   }
<   for (const auto& [key, value] : witness) {
<     u64 h = fnv1a(key);
<     uint signalSize = ctx->getInputSignalSize(h);
<     if (value.size() < signalSize) {
< 	    std::ostringstream errStrStream;
< 	    errStrStream << "Error loading signal " << key << ": Not enough values\n";
< 	    throw std::runtime_error(errStrStream.str() );
<     }
<     if (value.size() > signalSize) {
< 	    std::ostringstream errStrStream;
< 	    errStrStream << "Error loading signal " << key << ": Too many values\n";
< 	    throw std::runtime_error(errStrStream.str() );
<     }
<     for (uint i = 0; i<value.size(); i++){
<       try {
< 	      // std::cout << key << "," << i << " => " << Fr_element2str(&(value[i])) << '\n';
< 	      ctx->setInputSignal(h,i,value[i]);
<       } catch (std::runtime_error e) {
< 	      std::ostringstream errStrStream;
< 	      errStrStream << "Error setting signal: " << key << "\n" << e.what();
< 	      throw std::runtime_error(errStrStream.str() );
<       }
<     }
<   }
<   if (ctx->getRemaingInputsToBeSet()!=0) {
<     std::cerr << "Not all inputs have been set. Only " << get_main_input_signal_no()-ctx->getRemaingInputsToBeSet() << " out of " << get_main_input_signal_no() << std::endl;
<     assert(false);
<   }
< }
< 
< void writeBinWitness(Circom_CalcWit *ctx, std::string const &wtnsFileName) {
<   FILE *write_ptr;
< 
<   write_ptr = fopen(wtnsFileName.c_str(),"wb");
< 
<   fwrite("wtns", 4, 1, write_ptr);
< 
<   u32 version = 2;
<   fwrite(&version, 4, 1, write_ptr);
< 
<   u32 nSections = 2;
<   fwrite(&nSections, 4, 1, write_ptr);
< 
<   // Header
<   u32 idSection1 = 1;
<   fwrite(&idSection1, 4, 1, write_ptr);
< 
<   u32 n8 = Fr_N64*8;
< 
<   u64 idSection1length = 8 + n8;
<   fwrite(&idSection1length, 8, 1, write_ptr);
< 
<   fwrite(&n8, 4, 1, write_ptr);
< 
<   fwrite(Fr_q.longVal, Fr_N64*8, 1, write_ptr);
< 
<   uint Nwtns = get_size_of_witness();
< 
<   u32 nVars = (u32)Nwtns;
<   fwrite(&nVars, 4, 1, write_ptr);
< 
<   // Data
<   u32 idSection2 = 2;
<   fwrite(&idSection2, 4, 1, write_ptr);
< 
<   u64 idSection2length = (u64)n8*(u64)Nwtns;
<   fwrite(&idSection2length, 8, 1, write_ptr);
< 
<   FrElement v;
< 
<   for (int i=0;i<Nwtns;i++) {
<     ctx->getWitness(i, &v);
<     Fr_toLongNormal(&v, &v);
<     fwrite(v.longVal, Fr_N64*8, 1, write_ptr);
<   }
<   fclose(write_ptr);
< }
