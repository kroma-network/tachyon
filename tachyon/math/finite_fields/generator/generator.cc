#include "absl/strings/str_replace.h"

#include "tachyon/base/console/iostream.h"
#include "tachyon/base/files/file_path_flag.h"
#include "tachyon/base/files/file_util.h"
#include "tachyon/base/flag/flag_parser.h"
#include "tachyon/math/base/gmp/bit_traits.h"
#include "tachyon/math/finite_fields/generator/generator_util.h"
#include "tachyon/math/finite_fields/prime_field.h"

namespace tachyon {

struct GenerationConfig {
  base::FilePath out;
  std::string ns_name;
  std::string class_name;
  std::string modulus;

  int Write(const std::string& content) const;

  int GenerateConfigHdr() const;
  int GenerateConfigCpp() const;
  int GenerateConfigCudaHdr() const;
};

int GenerationConfig::Write(const std::string& content) const {
  if (!base::WriteFile(out, content)) return 1;
  return 0;
}

int GenerationConfig::GenerateConfigHdr() const {
  std::string_view tpl[] = {
      "// This is generated by //tachyon/math/finite_fields/generator",
      "#ifndef %{header_guard_macro}",
      "#define %{header_guard_macro}",
      "",
      "#include \"tachyon/export.h\"",
      "#include \"tachyon/math/finite_fields/prime_field.h\"",
      "#if defined(TACHYON_GMP_BACKEND)",
      "#include \"tachyon/math/finite_fields/prime_field_gmp.h\"",
      "#endif  // defined(TACHYON_GMP_BACKEND)",
      "",
      "namespace %{namespace} {",
      "",
      "class TACHYON_EXPORT %{class}Config {",
      " public:",
      "  constexpr static bool kIsSpecialPrime = false;",
      "",
      "  constexpr static size_t kModulusBits = %{modulus_bits};",
      "  constexpr static BigInt<%{n}> kModulus = BigInt<%{n}>({",
      "    %{modulus}",
      "  });",
      "  constexpr static BigInt<%{n}> kOne = BigInt<%{n}>({",
      "    %{one_mont_form}",
      "  });",
      "",
      "  constexpr static uint64_t ExtensionDegree() { return 1; }",
      "",
      "  static void Init();",
      "};",
      "",
      "using %{class} = PrimeField<%{class}Config>;",
      "#if defined(TACHYON_GMP_BACKEND)",
      "using %{class}Gmp = PrimeFieldGmp<%{class}Config>;",
      "#endif  // defined(TACHYON_GMP_BACKEND)",
      "",
      "}  // namespace %{namespace}",
      "",
      "#endif  // %{header_guard_macro}",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  mpz_class m = math::gmp::FromDecString(modulus);
  auto it = math::BitIteratorBE<mpz_class>::begin(&m, true);
  auto end = math::BitIteratorBE<mpz_class>::end(&m);
  size_t num_bits = 0;
  while (it != end) {
    ++it;
    ++num_bits;
  }
  size_t n = math::gmp::GetLimbSize(m);

  std::string content = absl::StrReplaceAll(
      tpl_content,
      {
          {"%{header_guard_macro}", math::BazelOutToHdrGuardMacro(out)},
          {"%{namespace}", ns_name},
          {"%{class}", class_name},
          {"%{modulus_bits}", absl::StrCat(num_bits)},
          {"%{n}", absl::StrCat(n)},
          {"%{modulus}", math::MpzClassToString(m)},
          {"%{one_mont_form}", math::MpzClassToMontString(mpz_class(1), m)},
      });
  return Write(content);
}

int GenerationConfig::GenerateConfigCpp() const {
  std::string_view tpl[] = {
      "// This is generated by //tachyon/math/finite_fields/generator",
      "#include \"%{header_path}\"",
      "",
      "namespace %{namespace} {",
      "",
      "// static",
      "void %{class}Config::Init() {",
      "#if defined(TACHYON_GMP_BACKEND)",
      "  %{class}Gmp::Init();",
      "#endif  // defined(TACHYON_GMP_BACKEND)",
      "}",
      "",
      "}  // namespace %{namespace}",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string header_path = math::BazelOutToHdrPath(out).value();
  std::string content =
      absl::StrReplaceAll(tpl_content, {
                                           {"%{header_path}", header_path},
                                           {"%{namespace}", ns_name},
                                           {"%{class}", class_name},
                                       });
  return Write(content);
}

int GenerationConfig::GenerateConfigCudaHdr() const {
  std::string_view tpl[] = {
      "// This is generated by //tachyon/math/finite_fields/generator",
      "#ifndef %{header_guard_macro}",
      "#define %{header_guard_macro}",
      "",
      "#include \"%{header_path}\"",
      "",
      "#if TACHYON_CUDA",
      "#include \"tachyon/math/finite_fields/prime_field_cuda.cu.h\"",
      "#endif  // TACHYON_CUDA",
      "",
      "namespace %{namespace} {",
      "",
      "#if TACHYON_CUDA",
      "using %{class}Cuda = PrimeFieldCuda<%{class}Config>;",
      "#endif  // TACHYON_CUDA",
      "",
      "}  // namespace %{namespace}",
      "",
      "#endif  // %{header_guard_macro}",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string header_guard_macro = math::BazelOutToHdrGuardMacro(out);
  base::FilePath hdr_path = math::BazelOutToHdrPath(out);
  std::string basename = hdr_path.BaseName().value();
  basename = basename.substr(0, basename.find_first_of("_cuda"));
  std::string header_path = hdr_path.DirName().Append(basename + ".h").value();
  std::string content = absl::StrReplaceAll(
      tpl_content, {
                       {"%{header_guard_macro}", header_guard_macro},
                       {"%{header_path}", header_path},
                       {"%{namespace}", ns_name},
                       {"%{class}", class_name},
                   });
  return Write(content);
}

int RealMain(int argc, char** argv) {
  GenerationConfig config;

  base::FlagParser parser;
  parser.AddFlag<base::FilePathFlag>(&config.out)
      .set_long_name("--out")
      .set_help("path to output");
  parser.AddFlag<base::StringFlag>(&config.ns_name)
      .set_long_name("--namespace")
      .set_required();
  parser.AddFlag<base::StringFlag>(&config.class_name).set_long_name("--class");
  parser.AddFlag<base::StringFlag>(&config.modulus)
      .set_long_name("--modulus")
      .set_required();

  std::string error;
  if (!parser.Parse(argc, argv, &error)) {
    tachyon_cerr << error << std::endl;
    return 1;
  }

  if (base::EndsWith(config.out.value(), ".cu.h")) {
    return config.GenerateConfigCudaHdr();
  } else if (base::EndsWith(config.out.value(), ".h")) {
    return config.GenerateConfigHdr();
  } else if (base::EndsWith(config.out.value(), ".cc")) {
    return config.GenerateConfigCpp();
  } else {
    tachyon_cerr << "not supported suffix:" << config.out << std::endl;
    return 1;
  }
}

}  // namespace tachyon

int main(int argc, char** argv) { return tachyon::RealMain(argc, argv); }
