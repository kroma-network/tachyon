#include <sstream>

#include "absl/strings/str_replace.h"

#include "tachyon/base/console/iostream.h"
#include "tachyon/base/files/file_path_flag.h"
#include "tachyon/base/files/file_util.h"
#include "tachyon/base/flag/flag_parser.h"
#include "tachyon/base/strings/string_util.h"
#include "tachyon/math/base/gmp/bit_traits.h"
#include "tachyon/math/base/gmp/gmp_util.h"
#include "tachyon/math/finite_fields/modulus.h"
#include "tachyon/math/finite_fields/prime_field.h"

namespace tachyon {

namespace {

base::FilePath BazelOutToHdrPath(const base::FilePath& out) {
  std::vector<std::string> components = out.GetComponents();
  base::FilePath header_path(absl::StrJoin(components.begin() + 3,
                                           components.end() - 1,
                                           base::FilePath::kSeparators));
  header_path =
      header_path.Append(out.BaseName().RemoveExtension().value() + ".h");
  return header_path;
}

std::string BazelOutToHdrGuardMacro(const base::FilePath& out) {
  std::vector<std::string> components = out.GetComponents();
  base::FilePath header_path(absl::StrJoin(components.begin() + 3,
                                           components.end() - 1,
                                           base::FilePath::kSeparators));
  return base::ToUpperASCII(absl::StrCat(
      absl::StrJoin(components.begin() + 3, components.end() - 1, "_"),
      absl::Substitute("_$0_H_", out.BaseName().RemoveExtension().value())));
}

// TODO(chokobole): Consider bigendian.
std::string MpzClassToString(const mpz_class& m, size_t n) {
  size_t limb_size = math::gmp::GetLimbSize(m);
  std::vector<std::string> ret;
  ret.reserve(limb_size);
  for (size_t i = 0; i < limb_size; ++i) {
    ret.push_back(
        absl::Substitute("UINT64_C($0)", math::gmp::GetLimbConstRef(m, i)));
  }
  for (size_t i = limb_size; i < n; ++i) {
    ret.push_back("UINT64_C(0)");
  }
  return absl::StrJoin(ret, ",");
}

template <size_t N>
std::string OneMontToStringHelper(const mpz_class& m_in, size_t n) {
  math::BigInt<N> m;
  math::gmp::CopyLimbs(m_in, m.limbs);
  math::BigInt<N> r2 = math::Modulus<N>::MontgomeryR2(m);
  uint64_t inv = math::Modulus<N>::template Inverse<uint64_t>(m);

  math::BigInt<N> one(1);
  math::BigInt<N* 2> mul_result = one.Mul(r2);
  math::BigInt<N>::template MontgomeryReduce64<false>(mul_result, m, inv, &one);

  mpz_class m_out;
  math::gmp::WriteLimbs(one.limbs, N, &m_out);
  return MpzClassToString(m_out, n);
}

std::string OneMontToString(const mpz_class& m, size_t n) {
  size_t limb_size = math::gmp::GetLimbSize(m);
  switch (limb_size) {
    case 1:
      return OneMontToStringHelper<1>(m, n);
    case 2:
      return OneMontToStringHelper<2>(m, n);
    case 3:
      return OneMontToStringHelper<3>(m, n);
    case 4:
      return OneMontToStringHelper<4>(m, n);
    case 5:
      return OneMontToStringHelper<5>(m, n);
    case 6:
      return OneMontToStringHelper<6>(m, n);
    case 7:
      return OneMontToStringHelper<7>(m, n);
    case 8:
      return OneMontToStringHelper<8>(m, n);
    case 9:
      return OneMontToStringHelper<9>(m, n);
  }
  NOTREACHED();
  return "";
}

}  // namespace

struct GenerationConfig {
  base::FilePath out;
  std::string ns_name;
  std::string class_name;
  std::string modulus;

  int Write(const std::string& content) const;

  int GenerateConfigHdr() const;
  int GenerateConfigCpp() const;
  int GenerateConfigCudaHdr() const;
};

int GenerationConfig::Write(const std::string& content) const {
  if (!base::WriteFile(out, content)) return 1;
  return 0;
}

int GenerationConfig::GenerateConfigHdr() const {
  std::string_view tpl[] = {
      "// This is generated by //tachyon/math/finite_fields/generator",
      "#ifndef %{header_guard_macro}",
      "#define %{header_guard_macro}",
      "",
      "#include \"tachyon/export.h\"",
      "#include \"tachyon/math/finite_fields/prime_field.h\"",
      "#if defined(TACHYON_GMP_BACKEND)",
      "#include \"tachyon/math/finite_fields/prime_field_gmp.h\"",
      "#endif  // defined(TACHYON_GMP_BACKEND)",
      "",
      "namespace %{namespace} {",
      "",
      "class TACHYON_EXPORT %{class}Config {",
      " public:",
      "  constexpr static bool kIsSpecialPrime = false;",
      "",
      "  constexpr static size_t kModulusBits = %{modulus_bits};",
      "  constexpr static BigInt<%{n}> kModulus = BigInt<%{n}>({",
      "    %{modulus}",
      "  });",
      "  constexpr static BigInt<%{n}> kOne = BigInt<%{n}>({",
      "    %{one_mont_form}",
      "  });",
      "",
      "  constexpr static uint64_t ExtensionDegree() { return 1; }",
      "",
      "  static void Init();",
      "};",
      "",
      "using %{class} = PrimeField<%{class}Config>;",
      "#if defined(TACHYON_GMP_BACKEND)",
      "using %{class}Gmp = PrimeFieldGmp<%{class}Config>;",
      "#endif  // defined(TACHYON_GMP_BACKEND)",
      "",
      "}  // namespace %{namespace}",
      "",
      "#endif  // %{header_guard_macro}",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  mpz_class m = math::gmp::FromDecString(modulus);
  auto it = math::BitIteratorBE<mpz_class>::begin(&m, true);
  auto end = math::BitIteratorBE<mpz_class>::end(&m);
  size_t num_bits = 0;
  while (it != end) {
    ++it;
    ++num_bits;
  }
  size_t n = math::gmp::GetLimbSize(m);

  std::string content = absl::StrReplaceAll(
      tpl_content, {
                       {"%{header_guard_macro}", BazelOutToHdrGuardMacro(out)},
                       {"%{namespace}", ns_name},
                       {"%{class}", class_name},
                       {"%{modulus_bits}", absl::StrCat(num_bits)},
                       {"%{n}", absl::StrCat(n)},
                       {"%{modulus}", MpzClassToString(m, n)},
                       {"%{one_mont_form}", OneMontToString(m, n)},
                   });
  return Write(content);
}

int GenerationConfig::GenerateConfigCpp() const {
  std::string_view tpl[] = {
      "// This is generated by //tachyon/math/finite_fields/generator",
      "#include \"%{header_path}\"",
      "",
      "namespace %{namespace} {",
      "",
      "// static",
      "void %{class}Config::Init() {",
      "#if defined(TACHYON_GMP_BACKEND)",
      "  %{class}Gmp::Init();",
      "#endif  // defined(TACHYON_GMP_BACKEND)",
      "}",
      "",
      "}  // namespace %{namespace}",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string header_path = BazelOutToHdrPath(out).value();
  std::string content =
      absl::StrReplaceAll(tpl_content, {
                                           {"%{header_path}", header_path},
                                           {"%{namespace}", ns_name},
                                           {"%{class}", class_name},
                                       });
  return Write(content);
}

int GenerationConfig::GenerateConfigCudaHdr() const {
  std::string_view tpl[] = {
      "// This is generated by //tachyon/math/finite_fields/generator",
      "#ifndef %{header_guard_macro}",
      "#define %{header_guard_macro}",
      "",
      "#include \"%{header_path}\"",
      "",
      "#if TACHYON_CUDA",
      "#include \"tachyon/math/finite_fields/prime_field_cuda.cu.h\"",
      "#endif  // TACHYON_CUDA",
      "",
      "namespace %{namespace} {",
      "",
      "#if TACHYON_CUDA",
      "using %{class}Cuda = PrimeFieldCuda<%{class}Config>;",
      "#endif  // TACHYON_CUDA",
      "",
      "}  // namespace %{namespace}",
      "",
      "#endif  // %{header_guard_macro}",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string header_guard_macro = BazelOutToHdrGuardMacro(out);
  std::string header_path = BazelOutToHdrPath(out).value();
  std::string content = absl::StrReplaceAll(
      tpl_content, {
                       {"%{header_guard_macro}", header_guard_macro},
                       {"%{header_path}", header_path},
                       {"%{namespace}", ns_name},
                       {"%{class}", class_name},
                   });
  return Write(content);
}

int RealMain(int argc, char** argv) {
  GenerationConfig config;

  base::FlagParser parser;
  parser.AddFlag<base::FilePathFlag>(&config.out)
      .set_long_name("--out")
      .set_help("path to output");
  parser.AddFlag<base::StringFlag>(&config.ns_name)
      .set_long_name("--namespace")
      .set_required();
  parser.AddFlag<base::StringFlag>(&config.class_name)
      .set_long_name("--class")
      .set_required();
  parser.AddFlag<base::StringFlag>(&config.modulus)
      .set_long_name("--modulus")
      .set_required();

  std::string error;
  if (!parser.Parse(argc, argv, &error)) {
    tachyon_cerr << error << std::endl;
    return 1;
  }

  if (base::EndsWith(config.out.value(), ".cu.h")) {
    return config.GenerateConfigCudaHdr();
  } else if (base::EndsWith(config.out.value(), ".h")) {
    return config.GenerateConfigHdr();
  } else if (base::EndsWith(config.out.value(), ".cc")) {
    return config.GenerateConfigCpp();
  } else {
    tachyon_cerr << "not supported suffix:" << config.out << std::endl;
    return 1;
  }
}

}  // namespace tachyon

int main(int argc, char** argv) { return tachyon::RealMain(argc, argv); }
